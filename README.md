# AWS Dynamic Credentials for Terraform Cloud

Goal of eliminating static credentials, benefit is reduce risk

The [AWS secrets engine](https://developer.hashicorp.com/vault/docs/secrets/aws) in Vault generates AWS access credentials dynamically based on IAM policies. This process is codified and mapped to internal auth methods (such as LDAP). The AWS IAM credentials are time-based and are automatically revoked when the Vault lease expires. 

TODO benefits of using Vault include revoke prefix, policy, audit, break glass, seal, api lockâ€¦

The [Vault provider](https://registry.terraform.io/providers/hashicorp/vault/latest/docs) allows Terraform to read from, write to, and configure HashiCorp Vault. The [vault_aws_access_credentials](https://registry.terraform.io/providers/hashicorp/vault/latest/docs/data-sources/aws_access_credentials) data source reads AWS credentials from an AWS secret backend in Vault. However, there are two important notes to be aware of when using this data source and the vault provider:

* All data retrieved from Vault will be written in cleartext to state file generated by Terraform, will appear in the console output when Terraform runs, and may be included in plan files if secrets are interpolated into any resource attributes. 
* The credentials leased from Vault during the plan are what must be used during the apply, and cannot be renewed. Ensure that the lease is long enough for Terraform to complete. 

To address and improve upon the first item, we can either provide the credentials to the workspace as environment variables, or to a tfc-agent outside of the terraform workspace. When done in this way, credentials will not be written to state, appear in the console output, or be included in plan files. 

To address and improve upon the second item, we can retrieve credentials a different way. Terraform Cloud Workload Identity provides a trust mechanism (OIDC compliant identity tokens) that enables  use workload identity tokens to distinguish between plans and applies and issue unique credentials for each run type. 

The result is a workflow where all cloud credentials are dynamically generated on demand, and scoped to a particular workspace and run type. They are not visible in console output, plan logs, or stored in state files. They are centrally authenticated, issued, logged, tracked, and revoked immediately upon completion of the run. 

## Proposed design 
workload identity + [agent hooks](https://developer.hashicorp.com/terraform/cloud-docs/agents/hooks)
1. Pre-plan hook authenticates to vault using unique per run token from terraform cloud
2. Fetches AWS dynamic secret for plans from that workspace
3. Provides it to the subsequent terraform plan
4. Post-plan hook revokes token and credentials
5. Pre-apply hook authenticates to vault using unique per run token from terraform cloud
6. Fetches AWS dynamic secret for applies from that workspace
7. Provides it to the subsequent terraform apply
8. Post-apply hook revokes token and credentials

Trust is determined by the per run JWT token. The agents themselves are given no permissions. 

## Demo

This repo:
* creates a demo Vault instance with the AWS secrets engine enabled
* deploys a terraform cloud agent to be used by terraform cloud workload identity
* creates a demo terraform cloud workspace with workload identity enabled

Requires:
* AWS credentials
* TFE_TOKEN for `tfe` provider auth
* fork the [hashicat-aws](https://github.com/hashicorp/hashicat-aws) repo to your github
* provided values for required [tfvars](./variables.tf)

In this example the tfc-agent can be run anywhere that has access to Vault. As opposed to [this tfc-agent-ecs example](https://github.com/assareh/tfc-agent/tree/master/tfc-agent-ecs), with workload identity the agent does not need to be run in the cloud with IAM because Terraform Cloud Workload Identity (JWT tokens) are used to establish trust. 

TODO
* stable ip
* container registry
* bring in vault module and use vault provider - remove public 8200 
